Designing Perlbot Plugins
=========================

Table of Contents
-----------------

1) So you want to write a plugin
2) A very simple example plugin
3) Plugin requirements
  3.1) init
  3.2) behaviors
  3.3) hooks
    3.3.1) hook
    3.3.2) hook_commandprefix
    3.3.3) hook_addressed_command
    3.3.4) hook_regular_expression
    3.3.5) hook_addressed
    3.3.6) hook_advanced
    3.3.7) hook_admin
    3.3.8) hook_event
    3.3.9) hook_web
4) Config files
5) Cleanup
6) The plugin help facility
7) The plugin info facility

1) So you want to write a plugin
--------------------------------

This document is meant for people who want to design their own perlbot
plugin, or anyone who's just interested in how the plugin system works.

Here are the things you'll need:

- You obviously need to know perl.  In particular, you'll need a clear
  understanding of perl references and classes/objects.  The "perlref" and
  "perltoot" man pages have all you need to know.  You won't need to
  design any classes, but you'll need to deal with some objects.

2) A very simple example plugin
-------------------------------

package Perlbot::Plugin::Example;

use Perlbot::Plugin;
@ISA = qw(Perlbot::Plugin);

our $VERSION = '1.0.0';

sub init {
  my $self = shift;

  $self->hook('example', \&example);
}

sub example {
  my $self = shift;
  my $user = shift;
  my $text = shift;

  $self->reply('I saw the command "example"!');
}

3) Plugin requirements
----------------------

  3.1) init
  ---------

All plugins should define an subroutine 'init' which is called when the
plugin is loaded.  Here you initialize your plugin, set up your behaviors
and hook appropriate events.

Example:

sub init {
  my $self = shift;

  $self->want_fork(0);

  $self->hook('hi', \&hi);
}

  3.2) behaviors
  --------------

You can define different behaviors for your plugin:

  $self->want_public(0|[1]);        # wants public text
  $self->want_msg(0|[1]);           # wants messages
  $self->want_action([0]|1);        # wants ctcp actions
  $self->want_chat([0]|1);          # wants dcc chat

  $self->want_fork(0|[1]);          # wants to be forked
  $self->want_reply_via_msg([0]|1); # wants to only reply via msg

Each of these wants either a 0 or a 1 as an argument.  The default values
are in brackets above.  If you don't want behavior different than the
default, you don't need to call these functions.

Example:

sub init {
  my $self = shift;

  $self->want_fork(0); # don't want to be forked
  $self->want_msg(0);  # don't want to get messages

  $self->hook('thing', \&someroutine);
}

  3.3) hooks
  ----------

Your plugin needs to hook diffent events to be of much use, so you'll
most likely need to use at least one of the following ways of hooking:

  $self->hook('command', \&callback);
  $self->hook_regular_expression('regular expression', \&callback);
  $self->hook_addressed(\&callback);
  $self->hook_advanced('command', \&callback);
  $self->hook_admin('command', \&callback);
  $self->hook_event('eventtype', \&callback);

    3.3.1) hook
    -----------

The hook method is an alias for calling both hook_commandprefix
and hook_addressed command as defined below.  This is the most
common type of hook.  If, for instance, your commandprefix was '!'
and you added the following hook for a math function:

  $self->hook('math', \&math);

Your irc session would look like:

<ender> perlbot, math 2+2
<perlbot> 4
<ender> !math 2+2
<perlbot> 4

As you can see, either a prepended commandprefix or a prepended
address to the bot will call your hook.

In addition, if the first parameter (the command) is empty or undef,
or you omit it entirely, every line will trigger your plugin.  You can
think of this as hooking on an "empty" command.  So you would hook
like this to make your "hello world" plugin trigger on every line:

  $self->hook(\&hello);

Then you would see:

<plastik> I am saying something
<perlbot> hello world
<plastik> Now I'll say another thing
<perlbot> hello world

    3.3.2) hook_commandprefix
    -------------------------

The hook_commandprefix method will hook a command issued with the
commandprefix in front of it.  If your command prefix is '!' and
you added the following hook:

  $self->commandprefix_hook('blah', \&blah);

When the bot sees '!blah some text here'.  It will call the callback
'blah' with a ref to $self, a user (if the person who said it was a
user) and the text 'some text here'. (it will strip the command)

    3.3.3) hook_addressed_command
    -----------------------------

The hook_addressed_command method will hook a command after the bot
has been addressed.  For instance:

  $self->hook_addressed_command('lala', \&lala);

Would get called back with 'so then' if a user typed into irc:

  yourbotnick, lala so then

    3.3.4) hook_regular_expression
    ------------------------------

The hook_regular_expression function will hook on a regular expression.
For instance, you could get yourself called on every line of text with
the following:

  $self->hook_regular_expression('.*', \&somesub);

You get passed the same type of stuff as the hook() call, but with
nothing stripped.

    3.3.5) hook_addressed
    ---------------------

This will hook any event in which the bot itself is address. If, for
instance, your bot was named 'samuelkins', then the following text
would trigger an event hooked in this manner:

  sameulkins, how are you?

You get called with the same arguments as hook, but with the addressed
part stripped, so you'd get 'how are you?'.

    3.3.6) hook_advanced
    --------------------

Exactly the same as hook, but you get the irc event passed as an
additional argument.

    3.3.7) hook_admin
    -----------------

The same as hook, but it will only be triggered by bot admins saying
the command.

    3.3.8) hook_admin
    -----------------

With this, you can hook any irc event you like.  To hook all messages:

  $self->hook_event('msg', \&something);

You just get passed a self ref and the event.

    3.3.9) hook_web
    ---------------

This allows plugin authors to 'hook' certain 'web events'.  It takes
as arguments: the hook, a coderef, and a description of what your
plugin is providing.  The bot will start a webserver on a
hostname/port combo specified in its config file if any plugins
request web hooks.  If you were to:

  $self->hook_web('myplugin', \&handle_web, 'My Plugin Stuff');

And a user went to the hostname:port/myplugin, your sub
'handle_web' would be called with all the path elements following
/myplugin.  So, if they entered:

  http://somehost.com:9090/mypluing/here/is/more

The sub 'handle_web' would be called with the array:

  ('here', 'is', 'more')

Your coderef must return in order:

  contenttype, content[, authtyperequired]

Where contenttype is something like 'text/html' or 'img/jpeg',
content is something like '<html><body>hi!</body></html>' and
the optional authtyperequired is one of the strings 'none',
'user' or 'admin'.

The default authtype is 'none', ie: open for anyone to use without
authorization.  'user' forces the client to enter a username and
password that exists in the bot config file and 'admin' requires
a username/password combination that is a bot admin. 

For good examples, see the StatsServer or LogServer plugins.


4) Config files
---------------

A perlbot config file is an XML file with a hierarchal collection of data
pertaining to bot settings.  Based on certain conventions, a given part of
the XML document tree may be interpreted as a scalar value, an array, or a
hash.  This all corresponds directly to the parsing behavior of XML::Simple
with forcearray=>1, as this is precisely what perlbot uses.  If you are
familiar with XML::Simple then you are in good shape, otherwise you ought
to read up and play around with it before reading any farther!  Remember
that forcearray=>1 will always create arrays, except in the presence of the
attributes name/id/key, in which case a hash is created.  So the overall
structure is (in perl terms) HoAoHoA, but with any of the aforementioned
attributes at a given level, an A becomes an H.

In older versions of perlbot code, a "config" was just the reference
returned by XML::Simple's XMLin function.  You had to traverse the hashes
and arrays yourself and watch out for numerous pitfalls.  When the 1.9.x
tree was started, the class module Perlbot::Config was created to
encapsulate some of the nastiness.  A "config" is now a full object of this
class.

The most commonly used method of Perlbot::Config is get().  get() takes a
list of strings or integers that serve as indices into the nested hashes
and arrays in the "raw" data structure returned by XMLin, to reference down
a branch to a specific node.  It returns the value at that node.  You
should always reference all the way to a leaf node, or else you will get
warnings and less-than-useful return values.  A nice idiom is to use the =>
operator (normally used in hash initializers) between the values, to
obviate the need for quotes and also to provide a nice visual mnemonic of
what's going on.  Remember however that if your final value is a literal
string, you'll still need to quote it.

If there is only one instance of a certain value or branch, instead of a
list, you may omit the '0' array index here and it will be inferred.  For
example, the <bot> section of the config contains the element <nick> for
specifying the bot's IRC nick.  There is only one <bot> section and one
<nick> element, so we don't need to say get(bot => 0 => nick => 0) .
Instead we can leave out the 0's: get(bot => 'nick') .  It is desireable to
leave out 0's in cases like this, as it makes the code far more readable.

In addition to get(), there is set() which takes the same key/index list,
but also an extra parameter as the value to store at that location.  To set
the bot's nick: set(bot => 'nick', 'new_nick') .

To make dealing with arrays easier, there are 4 methods: array_get,
array_initialize, array_push, and array_delete.  They all take a key/index
list as their first parameter, just like get and set.  You must only call
them on "leaf-level" arrays, i.e. arrays whose values are leaves in the raw
tree.  Calling them on arrays with "complex" children will probably not
work as expected.  array_get returns the values in an array; do not modify
these values directly, use the set method instead.  Note that array_get in
scalar context will return the size of an array, which is useful for
looping over a non-leaf-level array and accessing sub-elements with get().
array_initialize creates a new empty array at the specified location.
array_push pushes a value (its final parameter, as with set) onto the
specified array, creating the array if necessary.  array_delete deletes the
given value (its final parameter) from the specified array; note that the
value to delete is NOT an index but rather an actual value, making it work
like a hash deletion.  There is currently no way to "splice" from an array,
but this should be possible to implement if desired.

For hashes, there are 3 methods: hash_keys, hash_initialize, and
hash_delete.  The same rules and conventions from the array_ methods apply.
hash_keys returns a hash's keys.  hash_initialize creates an empty hash.
hash_delete deletes a value (the final parameter) from a hash.

All plugins are given a Config object that is limited just to the sub-tree
of the main config file rooted at the <plugin> element whose "name"
attribute matches that plugin's name.  Sound complicated?  Here's an
example.  For a plugin named "Foo", this <plugin> element would describe
some kind of server option:

<plugin name="Foo">
  <server>
    <hostname>www.someplace.com</hostname>
    <port>9000</port>
  </server>
</plugin>

You can access elements from your config by using your Perlbot::Config
object, accessible via $self->config .  This code would return
'www.someplace.com':

  $self->config->get(server => 'hostname')

If you really, REALLY need to look at the rest of the config, you may
access $self->perlbot->config to get at the entire thing, but PLEASE make
sure this is what you want/need to do.


5) Cleanup
----------

When your plugin is shut down, Perlbot will try to call the method
'shutdown' on it.  You can define this method if you have anything you
want to clean up.


6) The plugin help facility
---------------------------

Help for plugins is defined by creating a file 'help.xml' in your plugin's
directory.  It should have the following format:

<help>
  <overview>An overview of the function of your plugin.</overview>
  <command name="something">What the command 'something' does.</command>
  <usage name="something">something [some arguments]</usage>
  <command name="someotherthing">What 'someotherthing' does.<br/>More</command>
  <usage name="someotherthing">someotherthing [some other arguments]</usage>
</help>

If you define this file, Perlbot will automatically give users acess to your
help.

<command> tags can contain <br/> tags which will be interpreted as a 'line
break' by perlbot and sent as a new line in irc.

*** <usage> tags CANNOT contain <br/> tags!  They will also have the
    commandprefix PREPENDED to them automatically.  Be aware.


7) The plugin info facility
---------------------------

Info about your plugin is provided via a file 'info.xml' in your plugin's
directory:

<info>
  <author>Author's Name</author>
  <contact>author@place.com</contact>
  <url>http://web.address.com/plugin</url>
</info>

Please provide such a file with your plugin!
